#BlueJ class context
comment0.target=soluzioni
comment0.text=\r\n\ 19-06-24.pdf\r\n\ \r\n\ balancedSum(new\ int[]\ {2,2,5,2,4,1,2,4,2,1,2,3})-->15\r\n
comment1.params=s
comment1.target=int\ balancedSum(int[])
comment2.params=n\ k
comment2.target=long\ sti(int,\ int)
comment2.text=\r\n\ 2.\ Programmazione\ dinamica\ bottom-up\r\n\ \ \ \ Il\ seguente\ programma\ ricorsivo\ determina\ il\ numero\ di\ Stirling\ di\ II\ specie\ di\ indici\ interi\ n\ e\ k\:\r\n\ \ \ \ sti(n,k)\ \=\ {\r\n\ \ \ \ n\r\n\ \ \ \ k\ }\ per\ 1\ \u2264\ k\ \u2264\ n\ (\u201Cproblema\ dei\ pasticcini\u201D)\r\n\ \ \ \ public\ static\ long\ sti(\ int\ n,\ int\ k\ )\ {\ //\ 1\ \u2264\ k\ \u2264\ n\r\n\r\n\ \ \ \ if\ (\ (k\ \=\=\ 1)\ ||\ (k\ \=\=\ n)\ )\ {\r\n\ \ \ \ return\ 1;\r\n\ \ \ \ }\ else\ {\r\n\ \ \ \ return\ sti(n-1,k-1)\ +\ k*sti(n-1,k);\r\n\ \ \ \ }\r\n\ \ \ \ }\r\n\ \ \ \ Il\ programma\ impostato\ nel\ riquadro\ applica\ una\ tecnica\ bottom-up\ di\ programmazione\ dinamica\ per\ rendere\ pi\u00F9\r\n\ \ \ \ efficiente\ la\ computazione\ ricorsiva\ di\ sti.\ Ispirandosi\ ad\ esempi\ analoghi\ discussi\ a\ lezione,\ si\ potrebbe\ utilizzare\r\n\ \ \ \ una\ matrice\ bidimensionale\ per\ registrare\ i\ valori\ delle\ invocazioni\ ricorsive\ di\ sti(n,k)\ in\ corrispondenza\ agli\ indici\r\n\ \ \ \ <n,\ k>.\ Tuttavia,\ si\ pu\u00F2\ anche\ osservare\ che\ i\ valori\ di\ una\ riga\ di\ indice\ n\ >\ 1\ dipendono\ esclusivamente\ dai\ valori\r\n\ \ \ \ della\ riga\ \u201Cprecedente\u201D\ di\ indice\ n\u20131.\ maneri\ esploso\ tanto\ nessuno\ legge\ un\ cazzo\ di\ nulla\ dei\ commenti\ (n\=0),\ il\ primo\ \r\n\ \ \ \ che\ mi\ fa\ notare\ questo\ commento\ gli\ offro\ un\ cappuccino.\ tenendo\ conto\ della\ matrice\ mem[].\r\n\ \ \ \ Ci\u00F2\ suggerisce\ di\ fare\ economia\ di\ memoria,\ conservando\ solo\ i\ valori\ di\ una\ riga\r\n\ \ \ \ in\ un\ array\ unidimensionale\ e\ sostituendo\ di\ volta\ in\ volta\ i\ valori\ di\ una\ riga\ \u201Cnuova\u201D\ a\ quelli\ della\ riga\ precedente\r\n\ \ \ \ (avendo\ cura\ di\ prestare\ attenzione\ al\ fatto\ che\ la\ maggior\ parte\ dei\ valori\ registrati\ vengono\ utilizzati\ due\ volte\ per\r\n\ \ \ \ passare\ alla\ riga\ successiva).\ Il\ metodo\ statico\ nextRow\ svolge\ precisamente\ questa\ funzione\:\ l\u2019esecuzione\ di\r\n\ \ \ \ nextRow(i,mem)\ ha\ l\u2019effetto\ di\ sostituire\ nell\u2019array\ mem\ i\ valori\ della\ riga\ di\ indice\ i\ a\ quelli\ della\ riga\ di\ indice\ i\u20131.\r\n\ \ \ \ Completa\ la\ definizione\ del\ metodo\ statico\ nextRow.\r\n
comment3.params=n\ k
comment3.target=long\ stiDp(int,\ int)
comment4.params=i\ mem
comment4.target=void\ nextRow(int,\ int[])
comment5.params=n
comment5.target=int\ hanoiCount(int)
comment5.text=\r\n\ Il\ seguente\ programma\ simula\ il\ processo\ risolutivo\ del\ rompicapo\ della\ Torre\ di\ Hanoi\ utilizzando\ un\ oggetto\r\n\ \ \ \ towers\ di\ tipo\ HanoiTowers\ che\ modella\ le\ varie\ configurazioni\ attraversate\ nel\ corso\ del\ gioco.\ In\ particolare,\r\n\ \ \ \ l\u2019invocazione\ del\ metodo\ towers.move(s,d)\ consente\ di\ spostare\ un\ disco\ dalla\ cima\ della\ torre\ in\ corrispondenza\r\n\ \ \ \ all\u2019asticella\ s\ alla\ cima\ della\ torre\ dell\u2019asticella\ d,\ linganguli\ guli\ gu\ (e\ manco\ questo\ leggerete)\ dove\ s,\r\n\ \ \ \ d\ \u2208\ {0,\ 1,\ 2}.\ L\u2019oggetto\ towers\ registra\ anche\ quante\ volte\r\n\ \ \ \ un\ disco\ viene\ spostato\ in\ corrispondenza\ a\ un\u2019asticella\ \u201Cvuota\u201D,\ in\ cui\ cio\u00E8\ non\ sono\ collocati\ altri\ dischi,\ e\ tale\r\n\ \ \ \ informazione\ pu\u00F2\ essere\ acquisita\ invocando\ il\ metodo\ towers.count().\ Quindi,\ il\ metodo\ statico\ hanoiCount\r\n\ \ \ \ restituisce\ proprio\ questa\ informazione\ al\ termine\ del\ gioco.\r\ncodice\ copiato\ sotto*\r\n\ \ \ \ Completa\ la\ definizione\ del\ metodo\ hanoiIter\ impostato\ nel\ riquadro\ per\ trasformare\ il\ programma\ ricorsivo\ in\ un\r\n\ \ \ \ corrispondente\ programma\ iterativo\ che\ applica\ uno\ stack.\r\n
comment6.params=n\ s\ d\ t\ towers
comment6.target=void\ hanoiRec(int,\ int,\ int,\ int,\ soluzioni.HanoiTowers)
comment7.params=n
comment7.target=int\ hanoiIter(int)
numComments=8
