;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname draft) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
; procedura di supporto
; converte il carattere nel suo vero equivalente integer
(define char->true-integer ; val: integer (valuta anche stringa di un carattere)
  (lambda (chr)            ; chr: char o String da un carattere
    (if (string? chr)
        (- (char->integer (string-ref chr 0)) 48)
        (- (char->integer chr) 48)
        )
    ))

; procedura a supporto di bin-conv
(define bin-conv-supp ; val: String
  (lambda (str acc)   ; str: String, acc: integer
    (let ([scalar (char->true-integer (string-ref str acc))])
      
      ; IF:
      ; siccome non accorcio mai la stringa di ciclo in ciclo, l'unico controllo
      ; che posso fare è su acc rispetto alla lunghezza della stringa.
      ; Se la stringa ha lunghezza uguale ad acc+1, significa che sono arrivato
      ; all'ultima cifra di quest'ultima.
      (if (= (string-length str) (+ acc 1))
          ; true -> converti l'ultima cifra
          (* scalar (expt 2 acc))

          ; false -> somma in coda e chiamata ricorsiva
          (+
           (* scalar (expt 2 acc))
           (bin-conv-supp str (+ acc 1))
           )
          
          )
      )
    ))

; procedura che converte il valore inserito in input senza
; considerare la posizione di eventuale virgola (che sarà
; gestita da un'altra procedura apposita bin-divide).
(define bin-conv  ; val: integer
  (lambda (str)   ; str: String
    (let ([rev-str (reverse (string->list str))])
      (bin-conv-supp
       (list->string rev-str)
       0)
      )
    ))

; procedura di supporto
; rimuove il punto dalla stringa se presente
; mi è necessaria per fornire una stringa senza punto
; alla procedura sopra, bin-conv.
(define bin-absolute
  (lambda (str)
    (if (= (string-length str) 1)
        (substring str 0 1)
        (if (string=? (substring str 0 1) ".")
            (bin-absolute (substring str 1))
            (string-append (substring str 0 1) (bin-absolute (substring str 1)))
            )
        )
    ))

; procedura di supporto
; rimuove segno se presente.
(define bin-signless
  (lambda (str)
    (if (or (char=? (string-ref str 0) #\-) (char=? (string-ref str 0) #\+))
        (substring str 1)
        str
        )
    ))

; Test
;(bin-conv "01")
;(bin-absolute "0.1")
;(bin-conv "10")
;(bin-conv "11")

; procedura che determina l'esponente di 2 la cui potenza risultante
; dovrà dividere il risultato dell'operazione bin-absolute
; per ottenere il risultato corretto.
(define bin-divide ; val: integer
  (lambda (str)    ; str: String
    (bin-divide-supp (list->string (reverse (string->list str))) 0)
    ))

; procedura di supporto
(define bin-divide-supp ; val: integer
  (lambda (str acc)     ; str, acc: String, integer
    (if (= (string-length str) 0)
        0
        (if (char=? (string-ref str 0) #\.)
            acc
            (bin-divide-supp (substring str 1)(+ acc 1))
            )
        )
    ))

; Test
;(/ (bin-conv (bin-absolute "0.1")) (bin-divide "0.1"))
;(/ (bin-conv (bin-absolute "0.11")) (expt 2 (bin-divide "0.11")))

; procedura determinazione segno
(define bin-sign
  (lambda (str)
    (if (char=? (string-ref str 0) #\-)
        -1
        +1
        )
    ))

; Test
;(bin-sign "+01")
;(bin-sign "01")
;(bin-sign "-01")

; procedura di assemblaggio complessivo
(define bin-assembler
  (lambda (str)
    (*
     (bin-sign str)
     (/
      (bin-conv (bin-absolute (bin-signless str)))
      (expt 2 (bin-divide (bin-signless str))))
     )
    ))

; procedura di "facciata"
(define bin->dec
  (lambda (str)
    (bin-assembler str)
    ))

; Test
(bin->dec "+1101")
(bin->dec "0")
(bin->dec "10110.011")
(bin->dec "-0.1101001")
